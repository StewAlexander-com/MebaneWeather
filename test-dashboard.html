<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weather Dashboard Test Suite</title>
  <style>
    body {
      font-family: 'Helvetica Neue', Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
    }
    .test-container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    }
    .test-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
    }
    .test-header h1 {
      margin: 0;
      font-size: 1.5em;
    }
    .test-header p {
      margin: 8px 0 0 0;
      opacity: 0.9;
    }
    .test-controls {
      padding: 20px;
      background: #f9f9f9;
      border-bottom: 1px solid #ddd;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .test-controls button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #667eea;
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.2s;
    }
    .test-controls button:hover {
      background: #5568d3;
    }
    .test-controls button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .test-results {
      padding: 20px;
    }
    .test-section {
      margin-bottom: 30px;
    }
    .test-section h2 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 1.2em;
      border-bottom: 2px solid #667eea;
      padding-bottom: 8px;
    }
    .test-item {
      padding: 12px;
      margin: 8px 0;
      border-radius: 4px;
      border-left: 4px solid #ccc;
      background: #f9f9f9;
    }
    .test-item.pass {
      border-left-color: #4CAF50;
      background: #e8f5e9;
    }
    .test-item.fail {
      border-left-color: #f44336;
      background: #ffebee;
    }
    .test-item.running {
      border-left-color: #ff9800;
      background: #fff3e0;
    }
    .test-item-name {
      font-weight: 600;
      margin-bottom: 4px;
    }
    .test-item-details {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
    }
    .test-summary {
      padding: 15px;
      margin: 20px 0;
      border-radius: 4px;
      font-weight: 600;
    }
    .test-summary.pass {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .test-summary.fail {
      background: #ffebee;
      color: #c62828;
    }
    .dashboard-preview {
      margin: 20px;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
    }
    #dashboard-iframe {
      width: 100%;
      border: none;
      min-height: 600px;
    }
  </style>
</head>
<body>
  <div class="test-container">
    <div class="test-header">
      <h1>ðŸ§ª Weather Dashboard Test Suite</h1>
      <p>Elegant testing for core functionality with API mocking</p>
    </div>
    
    <div class="test-controls">
      <button id="run-all-tests">Run All Tests</button>
      <button id="test-threat-levels">Test Threat Levels</button>
      <button id="test-spc-mapping">Test SPC Mapping</button>
      <button id="test-alerts">Test Alerts</button>
      <button id="test-winter-weather">Test Winter Weather</button>
      <button id="test-errors">Test Error Handling</button>
      <button id="reset-dashboard">Reset Dashboard</button>
    </div>

    <div class="test-results">
      <div id="test-summary" class="test-summary" style="display: none;">
        <div id="summary-text"></div>
      </div>
      
      <div class="test-section">
        <h2>1. Threat Level Calculation</h2>
        <div id="threat-tests"></div>
      </div>

      <div class="test-section">
        <h2>2. SPC Risk Level Mapping</h2>
        <div id="spc-tests"></div>
      </div>

      <div class="test-section">
        <h2>3. Alert Processing</h2>
        <div id="alert-tests"></div>
      </div>

      <div class="test-section">
        <h2>4. Winter Weather Detection</h2>
        <div id="winter-tests"></div>
      </div>

      <div class="test-section">
        <h2>5. Error Handling</h2>
        <div id="error-tests"></div>
      </div>

      <div class="test-section">
        <h2>6. Dashboard Preview</h2>
        <div class="dashboard-preview">
          <iframe id="dashboard-iframe" src="Severe-Weather-Dashboard.html"></iframe>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // Test Framework - Simple and Elegant
    // ==========================================================================
    
    class TestRunner {
      constructor() {
        this.results = {
          pass: 0,
          fail: 0,
          total: 0
        };
        this.fetchMock = null;
        this.originalFetch = null;
      }

      /**
       * Initialize test framework and set up fetch mocking
       */
      init() {
        this.setupFetchMock();
        this.setupEventListeners();
      }

      /**
       * Set up fetch API mocking for testing
       */
      setupFetchMock() {
        // Store original fetch
        this.originalFetch = window.fetch;
      }

      /**
       * Mock fetch responses based on URL patterns
       */
      mockFetch(responses) {
        window.fetch = async (url, options) => {
          // Match URL patterns and return appropriate mock response
          if (url.includes('mapservices.weather.noaa.gov')) {
            return this.createMockResponse(responses.spc || { features: [] });
          }
          if (url.includes('api.weather.gov/alerts')) {
            return this.createMockResponse(responses.alerts || { features: [] });
          }
          if (url.includes('api.weather.gov/products') || url.includes('forecast.weather.gov')) {
            return this.createMockResponse(responses.afd || 'No significant weather expected.');
          }
          // Fallback to original fetch for other URLs
          return this.originalFetch(url, options);
        };
      }

      /**
       * Restore original fetch
       */
      restoreFetch() {
        if (this.originalFetch) {
          window.fetch = this.originalFetch;
        }
      }

      /**
       * Create a mock Response object
       */
      createMockResponse(data, status = 200) {
        return Promise.resolve({
          ok: status >= 200 && status < 300,
          status: status,
          json: () => Promise.resolve(typeof data === 'string' ? {} : data),
          text: () => Promise.resolve(typeof data === 'string' ? data : JSON.stringify(data))
        });
      }

      /**
       * Set up event listeners for test controls
       */
      setupEventListeners() {
        document.getElementById('run-all-tests').addEventListener('click', () => this.runAllTests());
        document.getElementById('test-threat-levels').addEventListener('click', () => this.testThreatLevels());
        document.getElementById('test-spc-mapping').addEventListener('click', () => this.testSPCMapping());
        document.getElementById('test-alerts').addEventListener('click', () => this.testAlerts());
        document.getElementById('test-winter-weather').addEventListener('click', () => this.testWinterWeather());
        document.getElementById('test-errors').addEventListener('click', () => this.testErrorHandling());
        document.getElementById('reset-dashboard').addEventListener('click', () => this.resetDashboard());
      }

      /**
       * Run all test suites
       */
      async runAllTests() {
        this.resetResults();
        await this.testSPCMapping();
        await this.testThreatLevels();
        await this.testAlerts();
        await this.testWinterWeather();
        await this.testErrorHandling();
        this.showSummary();
      }

      /**
       * Reset test results
       */
      resetResults() {
        this.results = { pass: 0, fail: 0, total: 0 };
        document.querySelectorAll('.test-item').forEach(item => item.remove());
      }

      /**
       * Add a test result to the UI
       */
      addTestResult(sectionId, name, passed, details = '') {
        const section = document.getElementById(sectionId);
        const item = document.createElement('div');
        item.className = `test-item ${passed ? 'pass' : 'fail'}`;
        item.innerHTML = `
          <div class="test-item-name">${passed ? 'âœ“' : 'âœ—'} ${name}</div>
          ${details ? `<div class="test-item-details">${details}</div>` : ''}
        `;
        section.appendChild(item);
        
        this.results.total++;
        if (passed) {
          this.results.pass++;
        } else {
          this.results.fail++;
        }
      }

      /**
       * Show test summary
       */
      showSummary() {
        const summary = document.getElementById('test-summary');
        const summaryText = document.getElementById('summary-text');
        const allPassed = this.results.fail === 0;
        
        summary.className = `test-summary ${allPassed ? 'pass' : 'fail'}`;
        summary.style.display = 'block';
        summaryText.textContent = `
          Tests Complete: ${this.results.total} total | 
          ${this.results.pass} passed | 
          ${this.results.fail} failed
        `;
      }

      /**
       * Test SPC risk level mapping (DN values to codes)
       */
      async testSPCMapping() {
        const tests = [
          { dn: 2, expected: 'TSTM' },
          { dn: 3, expected: 'MRGL' },
          { dn: 4, expected: 'SLGT' },
          { dn: 5, expected: 'ENH' },
          { dn: 6, expected: 'MDT' },
          { dn: 8, expected: 'HIGH' }
        ];

        const codeMap = { 2: 'TSTM', 3: 'MRGL', 4: 'SLGT', 5: 'ENH', 6: 'MDT', 8: 'HIGH' };

        tests.forEach(test => {
          const result = codeMap[test.dn] === test.expected;
          this.addTestResult('spc-tests', 
            `DN ${test.dn} maps to ${test.expected}`, 
            result,
            result ? `Correctly mapped DN ${test.dn}` : `Expected ${test.expected}, got ${codeMap[test.dn] || 'null'}`
          );
        });

        // Test invalid DN
        this.addTestResult('spc-tests',
          'Invalid DN returns null',
          codeMap[999] === undefined,
          'Invalid DN values should return undefined'
        );
      }

      /**
       * Test threat level calculation logic
       */
      async testThreatLevels() {
        // Test scenarios based on priority hierarchy
        
        // Scenario 1: Warnings override everything
        const scenario1 = this.calculateThreatLevel(true, 'HIGH');
        this.addTestResult('threat-tests',
          'Warnings override SPC risk (WARNING)',
          scenario1 === 'WARNING',
          'Active warnings should result in WARNING regardless of SPC risk'
        );

        // Scenario 2: Enhanced risk without warnings
        const scenario2 = this.calculateThreatLevel(false, 'ENH');
        this.addTestResult('threat-tests',
          'Enhanced risk without warnings (CAUTION)',
          scenario2 === 'CAUTION',
          'ENH/MDT/HIGH without warnings should be CAUTION'
        );

        // Scenario 3: Marginal risk without warnings
        const scenario3 = this.calculateThreatLevel(false, 'MRGL');
        this.addTestResult('threat-tests',
          'Marginal risk without warnings (MONITOR)',
          scenario3 === 'MONITOR',
          'MRGL/SLGT without warnings should be MONITOR'
        );

        // Scenario 4: No threats
        const scenario4 = this.calculateThreatLevel(false, null);
        this.addTestResult('threat-tests',
          'No threats (SAFE)',
          scenario4 === 'SAFE',
          'No warnings and no SPC risk should be SAFE'
        );

        // Scenario 5: Moderate risk
        const scenario5 = this.calculateThreatLevel(false, 'MDT');
        this.addTestResult('threat-tests',
          'Moderate risk (CAUTION)',
          scenario5 === 'CAUTION',
          'MDT risk should be CAUTION'
        );

        // Scenario 6: Slight risk
        const scenario6 = this.calculateThreatLevel(false, 'SLGT');
        this.addTestResult('threat-tests',
          'Slight risk (MONITOR)',
          scenario6 === 'MONITOR',
          'SLGT risk should be MONITOR'
        );
      }

      /**
       * Calculate threat level based on warnings and SPC risk
       * This mirrors the logic in updateDashboard()
       */
      calculateThreatLevel(hasActiveWarnings, spcRiskLevel) {
        if (hasActiveWarnings) {
          return 'WARNING';
        } else if (spcRiskLevel && ['ENH', 'MDT', 'HIGH'].includes(spcRiskLevel)) {
          return 'CAUTION';
        } else if (spcRiskLevel && ['MRGL', 'SLGT'].includes(spcRiskLevel)) {
          return 'MONITOR';
        } else {
          return 'SAFE';
        }
      }

      /**
       * Test alert processing logic
       */
      async testAlerts() {
        // Test alert filtering
        const alerts = [
          { properties: { event: 'Severe Thunderstorm Warning', severity: 'Severe' } },
          { properties: { event: 'Tornado Watch', severity: 'Moderate' } },
          { properties: { event: 'Flood Advisory', severity: 'Minor' } },
          { properties: { event: 'Information Statement', severity: 'Unknown' } } // Should be filtered
        ];

        const filtered = alerts.filter(alert => {
          const event = alert.properties.event?.toLowerCase() || '';
          const severity = alert.properties.severity?.toLowerCase() || '';
          return (event.includes('warning') || event.includes('watch') || event.includes('advisory')) &&
                 (severity === 'severe' || severity === 'moderate' || severity === 'minor');
        });

        this.addTestResult('alert-tests',
          'Alert filtering (warnings/watches/advisories only)',
          filtered.length === 3,
          `Filtered ${filtered.length} alerts (expected 3, excluding Information Statement)`
        );

        // Test warning detection
        const warnings = alerts.filter(alert => {
          const event = alert.properties.event?.toLowerCase() || '';
          return event.includes('warning') && !event.includes('watch') && !event.includes('advisory');
        });

        this.addTestResult('alert-tests',
          'Warning detection',
          warnings.length === 1 && warnings[0].properties.event.includes('Warning'),
          `Correctly identified ${warnings.length} warning(s)`
        );

        // Test no alerts scenario
        this.addTestResult('alert-tests',
          'No alerts handling',
          true,
          'Dashboard should display "No active alerts" when alerts array is empty'
        );
      }

      /**
       * Test winter weather detection logic
       */
      async testWinterWeather() {
        // Winter weather synonym dictionary (mirror from dashboard - comprehensive)
        const WINTER_WEATHER_SYNONYMS = {
          alerts: [
            // Advisories
            'winter weather advisory',
            'freezing rain advisory',
            'snow advisory',
            'wind chill advisory',
            'frost advisory',
            'lake effect snow advisory',
            'winter weather statement',
            // Warnings
            'winter storm warning',
            'winter weather warning',
            'ice storm warning',
            'blizzard warning',
            'wind chill warning',
            'freeze warning',
            'freezing rain warning',
            'snow squall warning',
            'lake effect snow warning',
            'extreme cold warning',
            'hard freeze warning',
            // Watches
            'winter storm watch',
            'ice storm watch',
            'blizzard watch',
            'wind chill watch',
            'extreme cold watch',
            'freeze watch',
            'freezing rain watch',
            'lake effect snow watch'
          ],
          phenomena: [
            // Snow terms
            'snow', 'snowfall', 'snowing', 'snowstorm',
            'snow squall', 'snow shower', 'snow flurries', 'flurries',
            'blowing snow', 'drifting snow', 'snowdrift',
            'lake effect snow', 'upslope snow',
            'accumulating snow', 'snow accumulation', 'snow totals',
            'snowfall rates', 'heavy snow', 'significant snow',
            // Ice terms
            'ice', 'icing', 'black ice', 'glaze ice',
            'freezing rain', 'freezing drizzle', 'freezing fog',
            'ice accumulation', 'ice buildup', 'ice storm',
            'ice formation', 'ice coating',
            // Mixed precipitation
            'sleet', 'sleeting', 'sleet pellets',
            'wintry', 'wintry mix', 'winter precipitation',
            'freezing precipitation', 'mixed precipitation',
            // Cold conditions
            'freezing temperatures', 'below freezing',
            'wind chill', 'windchill', 'wind chill factor',
            'extreme cold', 'bitter cold', 'dangerous cold',
            'hard freeze', 'freeze', 'frost',
            // Visibility/conditions
            'blizzard', 'whiteout', 'near-zero visibility',
            'winter conditions', 'winter weather',
            'hazardous winter weather', 'winter storm'
          ],
          severity: [
            'imminent', 'occurring', 'expected',
            'developing', 'arriving', 'approaching',
            'significant', 'hazardous', 'dangerous'
          ]
        };

        // Test winter weather alert detection
        function isWinterWeatherAlert(eventName) {
          if (!eventName || typeof eventName !== 'string') {
            return false;
          }
          const eventLower = eventName.toLowerCase();
          return WINTER_WEATHER_SYNONYMS.alerts.some(alert => eventLower.includes(alert));
        }

        // Test alert detection - comprehensive coverage
        const winterAlerts = [
          // Advisories
          { event: 'Winter Weather Advisory', expected: true },
          { event: 'Freezing Rain Advisory', expected: true },
          { event: 'Snow Advisory', expected: true },
          { event: 'Wind Chill Advisory', expected: true },
          { event: 'Lake Effect Snow Advisory', expected: true },
          { event: 'Winter Weather Statement', expected: true },
          // Warnings
          { event: 'Winter Storm Warning', expected: true },
          { event: 'Winter Weather Warning', expected: true },
          { event: 'Ice Storm Warning', expected: true },
          { event: 'Blizzard Warning', expected: true },
          { event: 'Freezing Rain Warning', expected: true },
          { event: 'Snow Squall Warning', expected: true },
          { event: 'Lake Effect Snow Warning', expected: true },
          { event: 'Extreme Cold Warning', expected: true },
          { event: 'Hard Freeze Warning', expected: true },
          { event: 'Wind Chill Warning', expected: true },
          // Watches
          { event: 'Winter Storm Watch', expected: true },
          { event: 'Ice Storm Watch', expected: true },
          { event: 'Blizzard Watch', expected: true },
          { event: 'Extreme Cold Watch', expected: true },
          // Non-winter (should be rejected)
          { event: 'Severe Thunderstorm Warning', expected: false },
          { event: 'Tornado Watch', expected: false },
          { event: 'Flood Advisory', expected: false }
        ];

        winterAlerts.forEach(test => {
          const result = isWinterWeatherAlert(test.event);
          this.addTestResult('winter-tests',
            `Winter alert detection: "${test.event}"`,
            result === test.expected,
            result === test.expected 
              ? `Correctly ${result ? 'detected' : 'rejected'} winter weather alert`
              : `Expected ${test.expected}, got ${result}`
          );
        });

        // Test winter weather detection from alerts
        function detectWinterWeatherFromAlerts(alerts) {
          if (!alerts || !Array.isArray(alerts) || alerts.length === 0) {
            return { status: 'none', hasAdvisory: false, hasWarning: false };
          }

          let hasWarning = false;
          let hasAdvisory = false;

          for (const alert of alerts) {
            if (!alert || typeof alert !== 'object' || !alert.properties) {
              continue;
            }
            
            const event = (alert.properties.event && typeof alert.properties.event === 'string')
                         ? alert.properties.event
                         : '';
            
            if (!isWinterWeatherAlert(event)) {
              continue;
            }

            const eventLower = event.toLowerCase();

            // Check for warnings (highest priority) - must exclude watch/advisory/statement
            if (eventLower.includes('warning') && 
                !eventLower.includes('watch') && 
                !eventLower.includes('advisory') &&
                !eventLower.includes('statement')) {
              hasWarning = true;
            } 
            // Check for advisories, watches, and statements (lower priority)
            else if (eventLower.includes('advisory') || 
                     eventLower.includes('statement') ||
                     (eventLower.includes('watch'))) {
              hasAdvisory = true;
            }
          }

          if (hasWarning) {
            return { status: 'warning', hasAdvisory: true, hasWarning: true };
          } else if (hasAdvisory) {
            return { status: 'advisory', hasAdvisory: true, hasWarning: false };
          }

          return { status: 'none', hasAdvisory: false, hasWarning: false };
        }

        // Test winter weather detection scenarios - comprehensive coverage
        const winterDetectionTests = [
          {
            alerts: [
              { properties: { event: 'Winter Storm Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Winter Storm Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Winter Weather Advisory', severity: 'Minor' } }
            ],
            expected: 'advisory',
            name: 'Winter Weather Advisory detection'
          },
          {
            alerts: [
              { properties: { event: 'Ice Storm Warning', severity: 'Severe' } },
              { properties: { event: 'Winter Weather Advisory', severity: 'Minor' } }
            ],
            expected: 'warning',
            name: 'Warning takes priority over advisory'
          },
          {
            alerts: [
              { properties: { event: 'Blizzard Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Blizzard Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Snow Squall Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Snow Squall Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Extreme Cold Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Extreme Cold Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Lake Effect Snow Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Lake Effect Snow Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Freezing Rain Warning', severity: 'Severe' } }
            ],
            expected: 'warning',
            name: 'Freezing Rain Warning detection'
          },
          {
            alerts: [
              { properties: { event: 'Winter Weather Statement', severity: 'Minor' } }
            ],
            expected: 'advisory',
            name: 'Winter Weather Statement detection'
          },
          {
            alerts: [
              { properties: { event: 'Severe Thunderstorm Warning', severity: 'Severe' } }
            ],
            expected: 'none',
            name: 'Non-winter alerts ignored'
          },
          {
            alerts: [],
            expected: 'none',
            name: 'Empty alerts array returns none'
          }
        ];

        winterDetectionTests.forEach(test => {
          const result = detectWinterWeatherFromAlerts(test.alerts);
          const passed = result.status === test.expected;
          this.addTestResult('winter-tests',
            test.name,
            passed,
            passed 
              ? `Correctly detected status: ${result.status}`
              : `Expected ${test.expected}, got ${result.status}`
          );
        });

        // Test threat level with winter weather
        function calculateThreatLevelWithWinter(hasActiveWarnings, spcRiskLevel, winterStatus) {
          if (hasActiveWarnings) {
            if (winterStatus === 'warning') {
              return { level: 'WARNING', description: 'Winter Precipitation Imminent and/or Occurring', icon: 'âš ï¸' };
            }
            return { level: 'WARNING', description: 'Active weather warnings in effect', icon: 'âš ï¸' };
          } else if (winterStatus === 'advisory') {
            return { level: 'MONITOR', description: 'Monitor for Winter Conditions', icon: 'â„ï¸' };
          } else if (spcRiskLevel && ['ENH', 'MDT', 'HIGH'].includes(spcRiskLevel)) {
            return { level: 'CAUTION', description: 'Elevated severe weather risk', icon: 'âš¡' };
          } else if (spcRiskLevel && ['MRGL', 'SLGT'].includes(spcRiskLevel)) {
            return { level: 'MONITOR', description: 'Monitor conditions', icon: 'â–¡' };
          } else {
            return { level: 'SAFE', description: 'No severe weather expected', icon: 'âœ…' };
          }
        }

        const winterThreatTests = [
          {
            warnings: true,
            spc: null,
            winter: 'warning',
            expected: { level: 'WARNING', description: 'Winter Precipitation Imminent and/or Occurring' },
            name: 'Winter warning â†’ WARNING with winter message'
          },
          {
            warnings: false,
            spc: null,
            winter: 'advisory',
            expected: { level: 'MONITOR', description: 'Monitor for Winter Conditions' },
            name: 'Winter advisory â†’ MONITOR with winter message'
          },
          {
            warnings: false,
            spc: 'ENH',
            winter: 'advisory',
            expected: { level: 'MONITOR', description: 'Monitor for Winter Conditions' },
            name: 'Winter advisory overrides SPC risk'
          },
          {
            warnings: true,
            spc: 'HIGH',
            winter: 'none',
            expected: { level: 'WARNING', description: 'Active weather warnings in effect' },
            name: 'Non-winter warnings override everything'
          }
        ];

        winterThreatTests.forEach(test => {
          const result = calculateThreatLevelWithWinter(test.warnings, test.spc, test.winter);
          const passed = result.level === test.expected.level && 
                        result.description === test.expected.description;
          this.addTestResult('winter-tests',
            test.name,
            passed,
            passed
              ? `Correct: ${result.level} - ${result.description}`
              : `Expected ${test.expected.level} - ${test.expected.description}, got ${result.level} - ${result.description}`
          );
        });

        // Test winter keyword detection in text
        function detectWinterWeatherInText(text) {
          if (!text || typeof text !== 'string') {
            return { status: 'none', confidence: 0 };
          }

          const textLower = text.toLowerCase();
          let score = 0;
          let hasWarningTerms = false;

          for (const term of WINTER_WEATHER_SYNONYMS.phenomena) {
            if (textLower.includes(term)) {
              score += 2;
            }
          }

          for (const term of WINTER_WEATHER_SYNONYMS.severity) {
            if (textLower.includes(term)) {
              score += 1;
              if (term === 'imminent' || term === 'occurring') {
                hasWarningTerms = true;
              }
            }
          }

          if (score >= 5) {
            if (hasWarningTerms || textLower.includes('winter storm warning')) {
              return { status: 'warning', confidence: Math.min(score, 10) };
            } else {
              return { status: 'advisory', confidence: Math.min(score, 8) };
            }
          }

          return { status: 'none', confidence: 0 };
        }

        const textDetectionTests = [
          {
            text: 'Winter storm warning issued for tonight with significant snowfall expected.',
            expected: 'warning',
            name: 'Text detection: Winter storm warning'
          },
          {
            text: 'Winter weather advisory in effect for freezing rain and ice accumulation.',
            expected: 'advisory',
            name: 'Text detection: Winter weather advisory'
          },
          {
            text: 'Snow and sleet expected to develop this evening with accumulating ice.',
            expected: 'advisory',
            name: 'Text detection: Winter precipitation mention'
          },
          {
            text: 'Sunny skies and mild temperatures expected.',
            expected: 'none',
            name: 'Text detection: No winter weather'
          }
        ];

        textDetectionTests.forEach(test => {
          const result = detectWinterWeatherInText(test.text);
          const passed = result.status === test.expected;
          this.addTestResult('winter-tests',
            test.name,
            passed,
            passed
              ? `Correctly detected: ${result.status} (confidence: ${result.confidence})`
              : `Expected ${test.expected}, got ${result.status}`
          );
        });
      }

      /**
       * Test error handling scenarios
       */
      async testErrorHandling() {
        // Test that error handling doesn't crash
        try {
          // Simulate API error
          const errorResponse = this.createMockResponse({}, 500);
          const test = await errorResponse;
          const handled = !test.ok;
          
          this.addTestResult('error-tests',
            'API error response handling',
            handled,
            'Error responses (status 500) should be detected (ok = false)'
          );
        } catch (e) {
          this.addTestResult('error-tests',
            'API error response handling',
            false,
            `Error handling failed: ${e.message}`
          );
        }

        // Test timeout handling
        this.addTestResult('error-tests',
          'Timeout handling',
          true,
          'fetchJSON uses AbortController for timeout (tested in integration)'
        );

        // Test missing data handling
        const missingData = { features: [] };
        this.addTestResult('error-tests',
          'Missing/empty data handling',
          missingData.features.length === 0,
          'Empty features array should be handled gracefully'
        );

        // Test invalid JSON structure
        const invalidStructure = { wrong: 'structure' };
        this.addTestResult('error-tests',
          'Invalid JSON structure handling',
          !invalidStructure.features,
          'Missing expected properties should be handled gracefully'
        );
      }

      /**
       * Reset dashboard iframe
       */
      resetDashboard() {
        const iframe = document.getElementById('dashboard-iframe');
        iframe.src = iframe.src; // Reload iframe
      }
    }

    // Initialize test runner when page loads
    const testRunner = new TestRunner();
    testRunner.init();

    // Run initial tests on load
    window.addEventListener('load', () => {
      console.log('Test Suite Ready. Click "Run All Tests" to begin.');
    });
  </script>
</body>
</html>

